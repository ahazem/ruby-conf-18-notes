Please stand by for real time captions.
>> [ Captioner on standby waiting for event to begin.  If there has been a change, please contact event organizer or  VITAC at 800-590-4197 or cc@captionedtext.com  Thank you ]for event to begin.  If there has been a change, please contact event organizer or  VITAC at 800-590-4197 or cc@captionedtext.com  Thank you ] Please stand by for real time captions.
>> Good morning how is everyone doing? How was last night? Were you in the Nation Building? Good. Maybe you guys can bring your shoes next time. That way we can all go for a run. Let's talk about parties. Tonight we have two parties going on. So do check out the parties page. They are doing a karaoke and it is such a long walk that I would see if you could get a ride. Would you guys please RSVP so we know who 
>> [ No audio ]
>> This is pretty cool history. I think we will start with Eric.
>> Thank you.
>> Good morning. How is everyone today? Well come, Welcome and today we want to talk about how to build authentic [Indiscernible ] . The star of the show is, community your -- and I want to tell you a little bit. My name is Sharon Yitbarek  and IM -- I am an immigrant. My father came to the US first and then my mother and I followed the -- and I grew up in a very typical Ethiopia household. If you do not know about Ethiopia do not worry I will tell you all about it. People did believe in education. He believed if you got a good grade, you should always get an A plus and he really believe then you could go to a good college. Like Harvard. He did not really know about Ivy leagues but he did know about Harvard. He wanted me to go into the most respective career which is being a doctor. But I failed. But he thought you would have a life, I would not say necessarily happy but successful. And he did not want me to be happy he wanted me to be successful. And so in order for me to follow, I had to have a distraction free environment. Having friends over, to have fun, absolutely not. Going to someone else's houses, where they were not doing homework? I do not think so. And the ultimate distraction, voice. -- boys. So the only community that I really knew and interacted with was the Ethiopia immigrant community. It is a relatively vulnerable one. Because everybody left everything behind. They went from one country to another country. It was a new world. And so many other kids did well. And they did typical stuff. They would have a family, and spouse. Many of them had to start a new career because their degree did not transfer. So when I got here, that's what so when they got -- when they got here they were not always safe. So the only safe place in our home was the living room. This is me and my mommy. We are so cute. And my mother was a community organizer. At at that point, when I was a kid, I would say this is a nice lady and she could cook good food. But nobody wanted to hang out with us. So looking back, we had a lot of nice people in our community. A lot of people could cook well. And there were people with bigger living rooms and more resources. So what made our living room magical? There are a few things that my mother did. She created a magical living room. She was the first to serve and last to eat. She would walk around and make sure that your plate was full. And maybe if she had a chance, she would grab a plate. She was so focused on making sure that we were taken care of. So what she told us, that we were the most important people in the room. Our needs were valued. The other thing she did, she lived by observing. She did not open the door and say, welcome to my party. But she watched. She would make sure you were happy and she would notice little things. She would notice, you did not eat from one of my dishes. Is something wrong? I would say, it is too spicy. She would say, okay. And she would not say anything. The next time, she would have a set of dishes, with [Indiscernible ] and she would pull you aside and say  this is for you. There was no announcement on how thoughtful she was. But she was observing. And she made you feel like, that you were important. The last thing she did, she would gather little problems. So as you know Thanksgiving is a American holiday. And we do have the day off and we are in America so we do celebrate that we have family over. She would do the turkey and mashed potatoes. One Thanksgiving if you years ago, we forgot gravy. And I said to my mom, we forgot the gravy. What are we going to do? Do we -- and do we have to go to the gas station to get gravy? How do we solve this problem? My mother said do not worry I will take care of it. So she grabs flower and spices that you -- she grabbed flour and spices and she made the best tasting gravy. You have to remember we do not really eat gravy. We do not do turkey gravy. But anyway she figured it out. Everyone was standing, watching and waiting for the gravy. At the end of the day Thanksgiving was not ruin because we did not have gravy. She jumped on it and she figured it out. And she made dinner more delicious for us. If you abstract some of the steps I talked about you might notice, there is a pattern. And the pattern is, she building. She was learning, she was observing and she was taking a step back. Do all of the steps look familiar? I hope they do. This is just like product building. This is something that we do all of the time. What are you doing? And it is not fundamentally different from what we are doing. Look at the sinks. -- Look at these things.
>> By doing all of these things she made us feel like we were valued. She made sure that we were safe. I am now an adult. I decided I want to learn to write code. And the code looks like this. Learning the code was painful and difficult. And the computer was always right. So I did this for a few months on my own and I decided to apply -- to school. When I got to boot camp, I was in a room with 30 other people who understood, what it felt like when nothing worked. And so for me the biggest value was the community. And when I graduated I felt so lucky and I was so excited. So when I graduated I was so excited because I was a real developer -- and I learned all of this stuff. That community of students, help me get across the finish line. The problem, that community and boot camp, cost me $11,000. And frankly this was on the cheap and. -- end. Even if you could afford that, not many people can go six months without an income. So this is considered a investment. Community is key. Community is everything. Do not worry. I am going to do something. I decided I was going to build a way for people to have that sense of community. I built something called code B. How many have chatted? A twitter chat, is a hashtag. You pick a time, during the day, and you deal with that twitter chat. You all get on twitter. You look at the hashtag. And you use the hashtag. And you can have a conversation that you can follow. So now I have this twitter chat medium. This is a way to find other developers. And at that point, this was three years ago, it seemed like everyone was doing a twitter chat. So I said, how do I build a magical twitter chat? How will it look? How will it be magical? We have three rules. To start off this way, and we done hundreds this way, what we are doing, telling you how we are going to behave and how you are going to behave. You better be nice and you better be helpful. And it signals to everyone else, what they have to accept if they want to join. If you need support or if you need help, this place will give you that. And the other thing we did, we were disgustingly, nice. If you tweeted us and said, I just finished a coating tutorial. You know what you will get? Five happy face him OG's -- happy emoji. What we are doing, we keep out people we find who is annoying. Can you go -- can you imagine if somebody said, you are so ugly and we respond by saying, we love you?[Laughter] 
>> It sounds like you what everybody in the community but you do not. You want to keep out the bad people. So when you are disgustingly nice with people they do not want to have a discussion with you. And that is totally fine. And I appreciate how serious this is. A few years ago, I woke up and had this horrible pain in my right shoulder. I could not even lift up my arm. Two minutes before the twitter hashtag started it was so bad, I was crying in pain. My has been, who is sitting right here. Raise your hand. He is so fine.[Laughter] [ Applause ]
>> My poor husband looks at me and says, I think we should go to the emergency room. I said no. I said I will dictate and you will type. So people were twitting. I would say to him, congratulate Susie. And so you are sending happy emoji to everyone now you realize how important this work really is. [Laughter] 
>> It is so important to say all of these wonderful things. Then I started to get a few messages, that said I love what you are doing. Let's give everybody support. When you do your twitter chat, it is 2 AM in the morning for me. Or I am at school. So this is when I realize that the developer and twitter have a comment -- common enemy. The footnote.[Laughter] . I was say, what am I going to do? I cannot twitter every single hour. Because I did have a full-time job. But if I could I could not do a chat every single hour. Maybe we could do with the alternate chat? Maybe we can do a morning chat Sunday morning. You can say, here is what I did this week. But here is the thing. If those people had not spoken up, we would not have a Sunday morning chat. Because that was an issue that was not on the top of my head. So now the chat is going awesome. But I realize with the twitter chat twitter is a great way to discover new people. It is so quickly and more efficiently getting -- on getting information. So I said, what is the better way? I thought, podcasting. This is a really great tool. When I looked at the technical podcast, what I understood, there are a lot of technical stories. It shows about how to nerd out eke out which is awesome. It is so interesting on who you can do this with. There is the whole story element. The people, the where and the how. And I found this was overlooked during the podcast. So I decided I was going to build a code. But how do you build a podcast that is magical? What does it look like? What does it mean? And so in our community it is important, about validation. This is huge. When you think about developers, they are dominant. You probably went to the top 10 school and now you are working at a big tech company. Or the other one is, you were born with the computer and you have been writing code since birth. But I knew that was not true. I knew that people became developers from multiple backgrounds. So what I did, I try to invest -- we try to think about race and gender. We look that languages. And how they became developers. We would hear stories of people, who have been writing code the day they were born. Here we have Chad [Indiscernible ] is another  good example, who did not start writing code until he was 22 or 23. So we created [Indiscernible ] . So if you want to do it and you put in the time, you belong here. So validation is super important. But yes you can do this. There is the fear that says, I am not made for this or I am not bored for this -- born for this. But there are so many ways to do this. This is the way you can pick your guests. A lot of times in our shows we do talk about technical things. Sometimes there is a technical term that the audience is not familiar with. Or they would say we test your code. But can you define what testing is? Especially for people who are not familiar with it. But can you define testing for someone who does not know what testing is? I know what testing is. You know what testing is. Other people should know what testing is. But we have to help them out. Sometimes it feels like charity. But it could be a little reminder for, kind of like saying, I should have known what that was. Or I have heard about that before but can you explain it? I tried to be the audience or try to be the person who does not know. After shell I have friends who will tell me, I know you know what that is. [Laughter] . But that is not the job. The other thing, I try to get out of the way. I am the hose, executive producer. But I am the least important person. I have to get out of the way. This is episode number eight. As you can see, the top row is my audio in the bottom is Chad's as you can see I do not say that much. In fact, I am not saying anything it is most that's mostly like sound effects. If you can mail the sound effects down you will be good -- nail the sound effects down you will be good. But it was Chad, it was his story. So I tried to give him the space he needs. This is one that we did with Scott Hamilton. I think Scott did talk a little bit more than Chad. But that was okay. The audience learned not for me. -- not from me. About a year ago we started a brand-new show. This came from a woman named [Indiscernible ] . I need to take you all everywhere because you are awesome. But anyway she graduated from the Flatiron school. That she did not have a computer science degree. But she wanted a -- in education. So she decided to teach herself. So she was going to log every week -- blog every week. When I saw this announcement I said, okay. This is a lot of worry that and work that might this is all -- this is a lot of worry and this is a lot of work. We need to make this accessible to the whole community. Now we do 20 episodes. And she is the teacher and she is teaching the computer science. Raise your hand if you have heard about Cortex? -- Someone said this is just like Car Tech for community -- for the computer community. I said thank you for putting this together it is so helpful. And it is important to me, I am blind. So a lot of the education is not made for me. And this is one of the [Indiscernible ] that actual  works. But when I read that, I was say, all of the stuff that I was doing, not once did accessibility cross my mind. So I question, how does this affect people in different ways? And in that email, it brought my attention to the fact about what happens if you cannot hear? You cannot listen to the podcast so what do you do? Now we do transcripts. But here is the thing. If that one listener had not spoken up, we would not have a transcript. This is something that I did not think about. Podcasts and twitter are all online products. You can participate you can download and you can subscribe. There is something about being, in real life. It is like being in this room and looking at all of your beautiful faces. There is something special about that. In my own career as a developer, this was super important to me. I really wanted to do something. Most conferences are not made for newbies. How many newbies do we have? I want to develop a conference for newbies. I want to make it magical. But what makes a magical conference? There are a few things that are important. It is important to follow and understand the talk. To be able to say, this is a good idea. When they go to technical talk, even if they are called beginner friendly I ask myself, is it really beginner friendly? When you learned your first language, it hurts. You do not know how to navigate the docs. And you should read them and not run from them. And remember you did not break the machine. It is all about learning the first language. Which can be hard. With your second language it is easier. You should consider reading the error message. So it is easier for you to look at something, and say that is totally normal. So when a developer hits the robot, that's what robot they will -- so when the developer hits a roadblock they will say, I need to do something different. So we have all of these buzzwords. And sometimes they are overwhelmed. Or frustrated. So to come back this and to help people, we created these conferences. And the conference booklet -- it is totally worth it. They can say I need two things from you. I want resources, so if they want to learn more about a topic they know where to go. And definitions. For every single talk, you get a little cheat sheet. So you have your terms and your definitions. So you know what the talk is for. And it is a great way, we are here. We are taking care of you. And this is so helpful. And the other thing that is super important, we need to understand, the Y -- the why. I know we get very excited about implementation. But we have to stop and say, who is this for? What are the side effects? For the new developer the bigger picture is super important. To make sure that we address this, I personally coached [Indiscernible ] . I went through their talk outline in their slides. I made sure that the message was going to connect with the audience. And the last piece, which is the most important one, the conference need to be financially accessible. Conferences can be super expensive. And a lot of us may take that for granted because we are working for a company that will pay for our hotel. Or they will subsidize a lot. But in some communities, they do not have a job yet. They could be teachers, nurses or bus drivers. So if they want to go to a conference they have to pay for it. Sometimes it is that -- a couple hundred dollars or $1000. One thing I appreciate about Ruby, conference, they try to move around. They tried to make it geographically accessible. So if you are a new developer, there is a big flight expense that you have to pay for. They could spend thousands of dollars for three days that may or may not help them become a better developer. So what we did to help the financial burden, we have what is called the opportunity scholarships. We cover what ever it is, whether it is the flight or Metro tickets. So conferences are off present -- conferences are so awesome. At a conference if you forget something or you miss something entirely, there is not much that you can do about it. And you have to take notes and hope you did it better. But here are the things that I wish I had done. We are going to call this Learning. One of the things that I learned, was captioning. Set up close captioning for every conference. [ Applause ]. How about that? This is something that I did not think about for my first conference. About a week before the conference they said are you going to do close captioning? It did not even cross my mind. What about childcare? How about having childcare at a conference? [ Applause ]. This is something that was not on my mind. Next one dietary restrictions. I asked everyone, about the dietary restrictions. I also told they cater your -- caterer to label the food. So we did not know if it was vegan or gluten-free. So people were trying to look for food that they could eat. Now they can find it. And here is a sweet attachment tweet -- and here is a tweet, I was worried about stalking. So there is a sticker that you can put on your badge that says, do not take a photo of me. This is from Hunter, where are you? Hunter tweeted directly at us. He said, do you want to ask people if they want a sticker when they sign in? So the next conference, I decided to fix all of these things. I am prior -- I am proud to say that we do have close captioning, childcare and dietary restrictions and stickers. But here is the thing. If all those people had not spoken up and said, hey have you heard about this, we would not have billed a better conference -- build a better conference. So I say now, look at all of the things that we did not get right the first year but look at how we improved the second year. Is there anything that we missed this year? Please keep your feedback coming. You can email me. Just let me know. For next year. After the conference, -- the first conference when I got back to my hotel room and I open up my email it was filled with feedback. On how to make the conference even better. So someone said, you should have a water cooler instead of water bottles. We had over 1000 water bottles. I was thinking it was super convenient. Because you could just grab and go. It is great for the conference but terrible for the earth. That was something that was brought to my attention. We had a few attendees trying to find a private place to pray. And so they say, this is something that you should think about next year. One of the lunches that we had was called a picnic. We had fried chicken, mashed potatoes. And I thought it was delicious. But when you have a menu that is that heavy and you are sitting in a room, and you have a lot of people, you get sleepy. And it may be hard to pay attention if you just had mashed potatoes. So now we have options. This never occurred to me. Because I love potatoes. And another one was bigger seats. Somebody wrote and said, I am a bigger person. And the chair is so small. And I was sitting there all day so it hurt my body. So I read these things. You can see this list. Now I have to worry if my furniture is inclusive. Now I have to think about all of these things. So now there are so many things to do. And so now my list is a whole lot longer. Now I had a list of things that I missed. So I was reading all of these emails but I was grateful. I was so thankful that people reached out to me. One email that I got from a woman, who gave me thorough feedback. I said thank you so much because it did give me a lot to think about. And I told her, you were so helpful, I want you to go to my other conferences. And she responded and said, this is the first time that I have done it -- giving me feedback -- she said she knew that I would do it. Many people do believe that I would fix it. But how did they know? How did they know that I would care enough to do all of these things? Because a lot of this is completely invisible. You do not see me sending hundreds of emails. You do not see me on the telephone. You do not see me carrying hundreds of booklets to my car. In fact the only thing that you see, or hear my voice asking questions and that is that. Most of the work is invisible. There is nothing that you can point to in say -- this thing that she does -- this huge X -- so how do you know? The only thing that is there, are the little acts. The little interactions. And it turns out that is what matters. Small consisted acts that build trust. It is not just one project. Not just one initiative. But it is part of the story. But it is just one part. It is small consisted acts. Constantly going through the loop, understanding, listening. Listening to the big and small problems. And this is what community building looks like. And when you do these things over and over again, that will make people feel safe and welcome. And you will eventually find your community. It is wonderful. And hopefully you found that today at this conference. So when you find people that are going to support you, love you and help you it is great. To belong and to be understood is amazing. But to create this environment is a lot of work. There is always something that you have to build or fix or make builder -- better. I know it is just like my mother, making the living room a magic place. She would always collapse at the end of the event. And she would sit and say I am so tired. But I would look at what she did. And I definitely did not want to be like that. But as I get older I am slowly churning into my mother. -- All I wanted was to be like her. I want to make you feel safe and welcome. Thank you.
>> [ Applause ] 
>> They Q -- thank you. What you see right now, it's not like it was a few years ago. We have such a great day.
>> [ Captioner standing by waiting for the next session to begin. Thank you ]
>> Hello everyone we're going to go ahead in get started -- and get started. I am the director for Track today. We have great talks for you today. As we go later through the day, [Indiscernible ] . Michael Harold, he spends his time writing and interviewing for his times. He contributes to open source projects and hashing. Michael does a visit national parks. Please welcome Michael Harold.
>> [ Applause ] 
>> Good morning everyone. How are you doing this morning? Did you have a good time at the party? Is everyone awake? How about this venue? We are in the Crystal Ballroom. And so live streaming looks like this. But it makes me nervous.  Because I think [Indiscernible ] is going to pop up and heckle me . Given where we are I want to be crystal clear about what I am talking about. [Laughter] 
>> No need to be fuzzy. But anyway. Now that all of my terrible puns are out-of-the-way, I want to talk about some -- subclassing hash. And if you have any questions, you can say hello. We are a company, for Word Press. But do not worry. We are looking for an engineer manager, if you are looking for a new job go ahead and talk to me. All right. So this talk, this is about Shashi -- this is going to make caching more powerful. It also might think -- more power -- but let's get back the Schmidt -- and so with great power comes great responsibility. To air is to be human -- to error is to be human.
>> We have three different bugs. And three different portions of the Hashing  library. And this is the frame for our story. First we will talk about the Hash extension. If you are a developer, you know it is access in support. It gives you the power without having to use active support. There is a bug in Hash library. To start off. Extensions. I wake up one morning and there is a bug report. It is a good report and it is very thorough. So if you look at the sample code you can see they have a subclass hash. If you know how Hash works out of the box, and it looks a little bit like this. And we get Hash get meow. But that is not where the bug lives. And here we have the different access. And this is where the problem lies. We can see that we can access the Hash with a Cat and this is the in different portion of the Hash. And you do not have to remember if you are using string keys. Especially when you are dealing with things that user has in place and things like that. And we get the Hash with a string of Dogs. Are you with me so far? So we are going to create our Hash again. And we want to grab the Dog Hash. Where we get no method error. But I do not see that anywhere. So when we look at the different and access, the extension, we have a merge method. This is called Super, and it reverts on the resulting [Indiscernible ] . And we have the convert method. So what is happening here? So we have the Hash so why do we not have access to the convert method? So we look at our Hash. We respond to the convert. I love Ruby. One of the favorite things in Ruby -- do you guys know what this is? I respond to convert. Then you respond. Then you have the Hash within the hash. Then you hit, true. So what is happening? We need to go deeper. So this is an introduction into my favorite tool. Anybody a fan of Ran -- Prime bug? And so this is how I go about diagnosing. So I urge the -- so I insert something like this. So we are going to tap into Super. This is the method on the object. This will access the object that you called, Cop on the Schmidt -- Tap on.
>> Now we can figure out what is going on. Then Tap returns. There is no functionality changes. We are going to say convert on the results. And when we do this, we call Hatch -- Hash Merge [Indiscernible ] . Now we can type in, interactive variables. The first thing is I want to know, and what I am dealing with. We see the result is Hash. And so they match and so they should be behaving similarly. We hit convert. Then we ask for the result. And didn't respond to the convert -- and did it respond to convert? Single 10 class, this is the instant of the class that the object is at a given point in time. When you call a method on the object, it crawls the singleton ancestors. To see if each module has a method on it. We can see we have the in different extension with the ancestors. That is why the South response to the convert. When we asked the same question, we see that the singleton class does not see the different extension and that is why we have a bug. So it does not know how to convert. And because of this we know we need to make sure that we -- the result of merge gets different access. Without doing that, it is just a normal Patch you have to respond to. Because of the implementation of the Merge method. When we do that Merge method we get Super. This is caching the implementation of the Merge. So what we get back from this, is a normal Patch even though we are asking for different access extension to give us the result. So in order to fix this read -- we are going to change this line. We are going to grab the Super result. And the result singleton class has different access in the ancestor list. Now they can respond to the convert. Once we make this change, we can run our test again. Bring up the, my hash. Look at the breed. Now it works. So why was this a problem? The source of the bad -- bug was because we called Super. This allows us, now we can change multiple extensions together and they can interoperate. But because we are coming from Hash, the base of Super is going to be the hash clash merge method. This is a singleton. If you ask how many public methods it has, currently there is 178. Aaron Patterson in 2014 route how this method is killing him. Talking about a memory link that happening rail. They use the action control parameters. Because there are 878 methods he goes on to explain you need to handle all of those methods because it is part of the class. I am not sure about any of you -- I would have a hard time covering 178. I'm not sure how to do that effectively. So we have to do this within our own code but that was just one problem. And it was easy to fix once we learn how to dig in. But let's look at a second problem. Mash. I wake up another morning, I get a a message. This is a pretty good bug report that explains to me what happened. How many people use Ashy? -- Hashy?
>> We do use they Mash inside of our application. And this is our library.. Assessment and 2014 -- through this blog he is talking about mash. He noticed that once you add [Indiscernible ] , to the Rail application, it means every single endpoint that 5% lower. Every single one. So he was trying to fix that. But it is a very interesting read. Let's go back to Mash. And it works a little bit like this. We say do you have a name property? And we can verify the batch name. We can also set the name. And when we ask for the name we get back Mash name back. And we have a main property set. And this is what people move -- use. That you will see here in a second. So if you Pasha Past -- so if you pass the hash key it will pass down. This is implemented through Method Messing. This is one of the sharpest tools. The implementation for this, if you receive a message that you do not know about, and you have a key that matches the method name will return. That gives us the ability to say, name, on mash. So we look at the suffix. If they key ends in the equal sign we will assign a property. If it is a question mark we see if there is a value with the hash. And you can build the next level of the Hash. If you ever need to generate the data structure, which I never recommend using. Then we can fall back to accessing our reader method. If none of the suffix exist. Clear as mud. There is one responsibility for this class. Mash was originally -- you could use it for Jason responses. And the reason it says that, is because that is what people would do. I am guilty of this. I have written more than one API client memory -- library. We get the response from the server and we converted into the hash. Now you do not have to define that interface. Now nothing bad can happen. But remember Mash is a Hash. It is in the definition of what we want Match to be. And remember there are 178 public methods. Here we have length and trust. But what happens if we say that we have a Hash Mash ? And you call the ZIP and you get a weird response. It is a great method but this is not what we want in this case. And because we implement all of the behavior, the method is not missing. And it is behaving unexpectedly. What should we do? We at Ruby, and a lot of the Ruby culture has been influencing [Indiscernible ] . It is just like making a sharp knife. So I made the method access override. You can mix this into your Mash . We are going to set [Indiscernible ] . And now it will behave as it expected -- as we expected. Now it works. I am alienating a numerator. Now ZIP  response how you expected to. If Aaron Patterson was in the audience, he would tell you never to do this. Because you have the method Hash . And when you are in production every single time you get the Hash for the entire application , it is bad for performance. This is really only for exploration. So this is what we have for Mash . Next we will talk about Dash. Then name for all of these things. We even have Trash -- and sometimes I have to look up what all of the mean. So we have Dash . So now you have a different bug report. This is a really good bug report. It goes through and gives you great examples. It is very long and it is very thorough. And this is a very good bug report. But I am saying, did you know that in Ruby you can have a Hash and you can treat it like JavaScript ? And you can flat it out inside of another Hash ? I did not know that. But it shook my world. So that is what he is talking about. And this is behavior -- and his behavior is broken out. So here you have a Hash . And you have Property. So this trend that specs and can only have the name value and the nickname value inside of it. Now it says, nope, it is not defined. So it is adding a level of not validation but preventing a backspace in your Hash . When we try to use this, we could say we can have the same variable. And now the nickname is Sam. We double splat out the results and we at height two it. -- to it. But when we tried to access height it says, I do not know what height is. But if we do it the other way. If we say the height is 6 m. Now it is clear as mud. If we call 2H first it still works. Why is that? What happens when we double splat? It uses the [Indiscernible ] . So when we create a Hash  method and we double splat it we get a [Indiscernible ] . Vertical. We are trying to double splat. In order to figure out what is going on right here we have to use a very powerful tool. So we wrap this up in a string. We call Ruby instructions. It will generate the instructions. This is going to run when you do this code. So now you will get a result. When we do this, we get Ruby assembly code. You do not have to understand what is going on. But it is interesting to dig into. But what we care about right here, are the instructions. You have the core, and name -- hash word. And this exists in C land. We find this function and it looks a little bit like this. I am not a C programmer. But I do see one thing that pops up. The RP2 Hash  type. So if the argument is not already a Hash  it has two hash method on it. But Ruby [Indiscernible ] only  when it is already in the Hash . And we are calling Dash a  Hash . It always has to be Hash . And it is not called to -- two Hash . But now we get what looks like a good result. So we try to merge on the height. And the property height was not assigned. So there is a second piece of the function that I showed. So Ruby, is basically a merge that happens only in C. Without coming back to your Ruby code it will do the merge of all of the key on the second argument to the self. And you get the resulting Hash . That is why we need the height variable. But we cannot access it. Dash  logic is in Ruby. When we do that double splat, it is a double 38 -- it is a double Dash . Unfortunately there is nothing we can do to fix this. Because it is the way the Ruby median works. This is actually a performance penalty every time you want to call a merge on a Hash and we do not want to do that . So we rode it up in, Read Me. We have a lot of, got you, in our library. Just to recap. We talked about in different access. This is an extension that we have in Ashy -- HashKey. You always can access the same thing. We talked about Matching Keys. And we talked about Mash . It allows you to wrap up a bunch of Hashs. And it interferes with the Hash method . Like I said there is 178 of them. We talked about the structuring the Hash . The way it is implemented in the median attachment this is something that we cannot fix. It is just something that we have to pay attention to. All three of these problems, are the root cause of subclassing Hash . Now I picked on Hash , because I am familiar with it. But anytime you are subclassing a subclass of Ruby you are gonna run into issues like this. String and a number of classes. All of those have a big surface area. And the method on the public interface. Many of which are implemented. So if you try to overwrite them they do not know -- it will not be quite as well as you think it would. This is something that you should be aware of what you are doing. The loglog -- blog  I showed you from Aaron. There is a sister blog that talks about HTML rails. Now you have us -- hundred and 78 and running. Now in the application code this may or may not be a problem. You may know exactly what you are going to get back from the response. -- There are 17 There are 1700 GEMs and I have to be aware of this. And you can run yourself into performance problems. So you have 173 methods. Do you think you could catch all of the cases? I know I cannot. I try all of the time so I know that I cannot. I have a little extra time. But wait. What about a wild PSA? We talked about Hash Mash . This is the devil. Here is a chronicle that has gone wrong over the years. It is pretty entertaining. One class in the library. So if you look at the Ruby data dump, this is any GEM in the top 1000 downloaded. And this link is not live yet but I will get you the link later today. The top 1001% -- of the top 1000 1% uses [Indiscernible ] . So my  [Indiscernible ] .
>> [ Captioner's transitioning ] [ Please stand by for realtime realtime  captions. ]

>>
>> Hey everybody, we will get started. Thanks for joining us again. My name is Megan, I am the track director. I am so excited about this next car. So much prep has gone into this one and I think you'll find it very fun and engaging and a great way into our next talk. Colin will be sharing with us how we dive into the garbage collector. Colin folded, example code that had to be labeled bad example. He works as a front-end over the web accessibility specialist for duo security. And organizer of the Ann Arbor web facility be up. They did design work for  please give a warm welcome to Colin folded. 
>> Can everyone hear me okay? Cool. As may just that my name is Colin folded. We have a lot to go over today so let's jump right in. You are a developer at a Ruby conference and you decided to take a very brave approach to go into the conference. You decided to go to a talk whose description most is that it was going to be about talking raccoons. This is an interesting choice. Good for you for deciding to do something a little bit different. Now I have a choice for you. Would you like for me to explain what the format of this talk is going to be? How we will go through this today you an idea of how we will progress learn about rubies garbage collector or do you want to figure it out as we go? How many would like to hear an explanation of what this talk is? And honey people just want to jump right in? Cool. Likely just made your first choice and that anything I was going to explain. All right. Once upon a time, you were working at your job, and you encounter this problem of server where processes were shutting down, you are getting all these memory you never have to do with memory before. You were a Ruby perform  Ruby programmer. You go on and look at the documentation, some blog post at all these weird terms like he add you are not quite sure what is going on. You take a little break. You ace in the office and turn the corner and right before you go off to your favorite coffee shop you notice right behind your office you see a little motion. Your turn around and you see interact with. Raccoons  this record is where a top hat and embroidered best so it catches your attention. You and recommend lot has an raccoons is like this, no one is actually supposed to notice me. It runs in a little tiny doorway you have never noticed. You are but at the same time it isn't every day you see a talking raccoons. UK staff here is. You chase after it. You come out into this gym with raccoons running about everywhere. It is the tables and all those tables are covered with pastry and airbrushing himself off you see that and friends look at you with a smile and say absolutely quality and you say what? You are a telephone  developer who doesn't understand who rubies garbage collector works. How do you know that? You understood me and whenever a human understanding animal that is how you human needs to go on some kind of allegorical adventure. And you say seems like you skipped a lot of exposition there. We have a lot to go over and you guys probably want to go to lunch. My name is patter, I recommend and I will take you on a guide of rubies is collector. Sometimes called the GC. You can call me the MC of the GC. We will have to simplify things a lot. Not dumb things down, everything I will tell you is real but it turns out that Ruby has a lot over time and it has been improved a lot so there are lots of little tiny edge cases. Don't worry about the fact we are similar findings. I want to give you an overview of how things work so you can better understand and you can take in later. What do you see before you right now? All these tables with raccoons and pastries everywhere. The pastries you are seeing is because you are hungry. Those are Ruby objects. We are inside the memory of a computer running Ruby. All those pastries or objects you see. Hold on, I am a smart developer. I want to see how it really works. I don't want these fun cute abstractions. You see yourself shrieking down until you are smaller than in Adam. You feel yourself by Sylvia happens. Electrical field around you. Virtual photons. What is going on? Ones and zeros and you year patters voice. It doesn't deal with ones and zeros. Computers really work with physical devices with electrons and charges moving on. A lot of quantum mechanics. That will not be very helpful. Exactly. Ones and zeros in a computer you talk about programs, all those things are just abstractions to help us understand the. When you're looking at pastries, don't think about that as John, that is an abstraction to help you understand things better because no one can understand how this works. You're right back to the roomful of delicious pastries and raccoons. What I will explain she was not to appreciate what the garbage collector dollars and what is job is. I will not go too much into detail but if you want to go into details we can take a  data in a little. It empowers you to learn more. UK go to another conference talk talks more detail and have a better understanding of what they are talking about. Or you encounter a blog, you will understand the concepts and ideas and you will be empowered to learn more on your own. That is really what you need is a computer programmer. You don't need to know need to know how to learn more. And I would come to our first choice. If you don't know what a garbage collector is or maybe you have heard of it you are not really sure, we can bury  very briefly talk about what a garbage collectors. If you want to learn about how computer memory works and what goes in to actually making a garbage collector to understand maybe want to know how it does that we can talk a little bit about that. How many people want to just a basic brief overview of what a garbage water does. Is only a couple people. You can come see me afterwards if you want to see any part of this talk title go over and how many people want to learn about how computer memory itself works? As you to patter and say I want to understand how  what is this place? How does this memory work? And so patter points to the room and says each of these tables you see before you, that is a region in memory that has been reserved for a program. Each of those pastries is a day  bit of data has been stored in memory. There is an area and you can put objects or data in. You may goes every single the table has a number on it. That number is what is often called an address. It's a unique ID to locate something in memory. If you don't have the actual data for something you can hand a function to say go out to this address and get whatever data is there. When we take one of these index cards, we call  you can think of pointers like indexes into an array. It is one way to think of it, a pointer is an index into some particular part of that right. If you go to this  there will be something on their. You can put any data on the winter. The pointer has no idea what is underneath it. It just gives it a location. There are two basic kinds of way they gave to get at memory. One is with local variables. This will be something that you are just going to  if you have a function, you quickly want to print out hello world. Maybe your entire just prints out hello world. You will create a string and the compiler will figure out how to store that in memory of Mr. Mr. that up and remove it from memory. Local variables are only used for the duration. Think of this as a quick little snack, maybe a crate. You just unit and as soon as you are done quickly through way. You will not keep it along time. But see want to do something you want to last. Ruby functions. We wanted to last for the duration of the program. Will we want something to last for a longer period of time, a function called   It takes an argument the size of the amount of memory and when you call it stands for memory allocate. The program will go  I need a stretch of memory that is this a. You don't say where it will be you say I want a stretch of memory this way and it will retrain pointer to these heart of that bit of memory. You can keep track of how think that area of memory is associated with that pointer. You have to keep track of where things are in memory, how much memory they take up and you can hear this when you call malloc a table of a certain length. And then how long it is and see if it calculates out where the end is. If you try and place a pastry past the end of the table will fall on the ground, he will get destroyed in your program is probably going to end. That's how malloc works. We have allocated at memory. We only allocated memory over and over again more data eventually run your machine. There is also a function called free. You give it a pointer to the start of memory and that all the operating system I am John with the table and remove it and then that memory can get used some of the program. You need to keep track of what memory you are using and when you are that you have to make sure to bring it so other programs are free to use that. Rubies garbage collector does not free garbage collected objects. Ruby will reserve a long stretch of memory which it calls a page, which is confusing. This page is just a stretch of memory where Ruby store some of the  on the table inside of memory where you can store more pastries. When the garbage collector  it does not actually remove the old table. There may be other objects that are still active other and Ruby knows that 2 MB of pastry stored in memory you are probably at some point going to make a similar model. It wants to keep that because malloc and free takes time to execute. Ruby will malloc memory reserve it for you and put objects there garbage collector decides to delete them it keeps that memory and overrate that pot with a new object every single time. Ruby programs only grow in the amount of memory they use. They will allocate as much memory as they keep memory so the next time you try and create an object it will fill out whatever space it has a clean face as a ghost. Now have a couple choices for where we can go next. You can learn how everything I just told you is actually a lie, computer memory as we were complicated than that and I find it really fun to find out that computers just barely work. They work really well but if you see how complicated computer memory is you will be surprised you are able to turn the computer on. We can skip past that and go right had to learn how Ruby figures out what to delete and don't worry, with these earlier choices, you will still have an opportunity go back to these later choices. We will start a space to learn about how Ruby figures out what to delete and we will get ready that. Those will be are two choices. How many of you want to learn about how everything I just told you is a lie and how many people want to have to figure out what Ruby and how to delete? We will still get to that. You turn to patter and say this seems pretty simple. Malloc regions of memory and let me give you a secret. It turns out Ruby memory and it is actually way more complicated than that so let me give you a little glimpse into how computers really work because if everything works the way I just told you, whenever you ask for memory the computer would get it. Your computer would run much slower so a lot of tricks had been added over time to make it faster. A gigantic telephone. You create a new object in Ruby your Ruby program goes out and it tells Ruby itself I just created this object, put it in memory, there is enough base it will put it there. If there is not enough base Ruby has to go out and talk to malloc and free to ask for more memory. Malloc as I told you is a function. There are different implementations of malloc. Sometimes when you asked for a region of memory, it may ask for even more memory from the operating system and give you a small slice of that. It takes time to malloc memory. Takes more than you asked for the next time you can give you more those two tables will be right next to each other. There are certain performance reasons that might be nice. When you free memory and may not actually go ahead and retirement  returned to the operating system may hold onto that system and say I will delete it and use that in there and next time when you ask for a day memory it says I have the memory right here. I totally didn't keep it around from last time. You can use it again. This house faster. Malloc and free are asking for memory from the operating system and the operating system is complicated and they are dealing with memory from the largest rather than these tiny bits we ask for so they can run more efficiently. When you ask for memory they be secretly actually give you more memory than you  ask for memory then you asked for more efficiencies. They may not necessarily delete it. And in a case operating system it is important to keep in mind the operating system is controlling your computer by talking to the Seaview.  Talking to the CPU. Modern CPUs are built on lies. Do this multiplication to do this addition is often memory. That CPU may execute those steps in a completely different order. It is trying really hard to make your code run faster. It will mix things up and as long as it gets the same result you don't care. If you have a branch statement. And if statement. In the Seaview were to wait until  that would take a lot of time. The CPUs these days have dreams predictors. They will gas whether or not that is going to go in the true or false direction evaluating time. If it made the gas correctly that is awesome. It gases the wrong thing it has to rewind back and undo all the calculations and start on the other branch and Goldberg. We normally don't see this. There have been security vulnerabilities related to this but CPUs are complicated. Anytime anyone tells you this is how a CPU works, that is probably a lie. But no one really fully understands how they were because they are so complicated. Those abstractions make it a lot easier to think about. The Seaview will try and store stuff in memory but when you try to read stop it will story locally. It takes a long time to go and talk to random and ask for memory. It may cash more than you asked for. If you ask memory it will get that entire tables it makes the cost have been out front to the whole table and if you ask little pastry on a table and have a local copy of it and it will return those one by one. The CPU may say I'm going to go that cash is that weight for a convenient time he can talk to RAM. 
>> Which brings us to memory itself. Most computers today have last memory which sometimes things will get story there is enough space. RAM is going to store stuff in a completely different order you want and cash, it will make stuff go faster. If your store stuff in flash memory, it is just ridiculous. It may store the number 552 and somehow remembers hundred 52 is a seven year and is doing because it is incredibly complicated and flash memory is based on a lot of really broken technologies they had to have a lot of duct tape to to make it work. It works really well and it goes really fast because of all the stuff. Is a total hot mess on the inside. How do you years actually work? Everyone is like to each other. The way it all works is everything has been designed by very good engineers and we have been through a lot about some problems and each one of these lies, I will store something memory and that it was actually do it. It may actually  as long as remembers, it could store it in a different location as long as the next time you ask or it goes out and get the same thing. That is a brief introduction to the crazy game of top  telephone. If your regular computer is built on magic on lies, that is why computers are really no one really understands this stuff so don't feel too bad. Now have a couple choices. We can learn how Ruby figures out what to delete, the main subject for this talk, and I don't know why you would want to learn about this, we have more acute illustrations coming up. Learning how the garbage collectors but if you don't want to do that we can skip implementation details if you are familiar with the mark and sweep algorithm. How many people want to learn how markets we works? And how many people want to skip ahead to implementation details? Cool. Thank you for being honest. Honesty is appreciated here. You turn to patter and say this is cool, I am very confused about how computer memory works but you say that a job is to delete things once we are done with them. I create new objects that get story memory and when they get deleted but I never tell Ruby want to do that is Ruby figure that out? Let me take you over to my friend Mark. Direction is dressed up in a letter  little banker outfit. Running around and it is hard to figure out patterns that come over here. Mark says I'm really busy because this process is running. There are two parts to the Ruby garbage collector. Mark and sweep. My job is to figure out what bits of memory you can delete so later we can be but that memory and delete it. We say whatever memory has been marked for deletion by me, we can go ahead and delete. How do I do my job? I will pull up  let me give you an analogy. What object can we delete? This cake over here. This cake is for a two-year-old birthday party. It's a little bit chaotic, along program and if you were to throw away the cake with Rachel-year-old birthday party, all hell will break loose. We know for a fact that this cake should not be thrown in the trash until the party is over. There may also be pieces of that cake that been cut off. That are stored elsewhere in memory. We need to go out and figure out other pieces of cake that are still in people's hands? If you have ever tried to pull away piece of cake from a two-year-old. I personally have not done it but that is because I do not have a death wish. If someone put down a piece of cake and maybe there is usually don't want to delete it. Even though they are not using it now is birthday party still going this is a is true. Some Ruby objects we should not delete because they are part of a currently active process or is Ruby objects are associated with something that should never get delete it. We are never going to garbage collect a const because it can be accessed at any point in your program. We will market that  there may be objects memory that are associated with a method that is currently being run. We don't want to delete those. There is a method that is currently running. There are objects associated with those two things which it may be an element an array that maybe you don't record somewhere but because as part of an array that is to use we want to make sure we see me because one might use it later. Mark pulls out a blackboard says let me show you how this works be. Also Ruby code and draws out boxes. This Ruby code, very simple program. And is offices are different blocks in Ruby memory. Places on the table where we can store objects. Let's evaluate this program. We define a method and I will hand it  let's imagine you get parsed and interpreted. Figures out how to run that instruction. Now I want to do and these are the instructions I should run. And we get to this line here. We are creating an array and that already has one string in it. First Ruby will evaluate us. This is an object. Even though we did not call . new. String literal will create a new object. Next we have this array which is wrapping it and so we need to create an array memory. Inside that array we had a pointer to say this array contains this particular object. That way we know this raised next to that object in Ruby. There is a connection between the two. That we go onto line 7, we pass in this array. We go to that method. In the first thing is it pushes on the string. This is not necessarily a good thing to do in your program. Mutating things you get in as arguments could cause problems. Let's say we push on this that says and friends. We need to store that in memory and output hello NA, separated list of all these different names. This is an interrelated string so we have to store that little tiny,. Then we call name . join. That will return a string so we have to store the result of that in memory and I have to evaluate that string interpolation that creates another string and we have to store that in memory and now we are done calling the method. Finally we want to help with the string and here is where we encounter a problem. All these us are taken up now. There is nowhere in memory to store the. Ruby could go out and ask for memory but some of these objects we allocated are not the. Let's figure out if we can delete so we can free up space. Your program staff and Ruby's garbage collector starts. Mark is going to run around in the first thing they will do is part of the market is of Bismarck every single objects with a waiflike. A little market to that says this particular object in memory has not yet service letter. The white flag means we haven't evaluated whether or not this objects to be garbage collected. The next thing we want to do is Mark all the objects that obviously should not get garbage collected. We mark those with a grace like. That first rate memory, puts you all is in the same scope is where that array was created. It might get used later in the program. The Grayslake means we should not garbage collect this object but we don't yet know if it is connected to other objects in memory they are connected, we do not want to collect those objects. Indicates that the array we will take a look, now we will evaluate what is connected. We will see that Ruby is connected to it because it is inside of that array. We cannot collect that. Is part of an array and it is a viral. If you are inside something you cannot be collected. We will Mark that with a Grayslake and say this is also in an array that cannot get collected. Now we have looked at all of the contents. All objects associated with that array. We market with a black flag. Like a Grayslake a black says this object is one that we cannot collect. But it means we have evaluated everything connected to the subject so the garbage collector no longer has to look at it. Everything is good. Now what Ruby will do is start the cycle over again and take a random object that has a Grayslake and finally connections to it. There isn't anything connected to it. We market with a black flag and we have this straight here, and friends. We have gone through every single item in memory that has a great flag. We have gone through either has a black flag or a white flag. The black flag means we have looked at that object already, we looked at every object connected to it we know we cannot garbage collected. The white flag means we have not looked at it. If there are no were great flag all those objects with waistlines are not connected to think we cannot collect. Therefore we can delete all these objects. Nothing is going to care if they go away because nothing has a connection. We can delete everything marked with a white flag and start evaluating our program again now that we have freeze but memory. Let's say that we did not manage to create enough space, then we have to go out and allocate more memory. Another table and we would have even more. Next time will have more spots to look at to run this algorithm. This is the mark and sweep algorithm. We figure out all the connections between them and any objects we have not marked, might be used in the future, we delete. Night you have a couple choices. Do you want to learn how a Ruby program currently commemorate? A Ruby program could leak memory? Even though it had a garbage collector it still can leak. Does a garbage collector really have to be so complicated? Is there a simpler way we could write a garbage collector? Or we could skip ahead and talk about how rubies curve is Carter has been getting faster. There are really cool and fun algorithms. Really cool algorithms that have been added to Ruby over the years to make it even faster. We just ran what you start right now Ruby would be a lot slower. How many people want to learn about memory leaks? How many people want to learn about a simpler garbage collector out? And how many people want to learn about Ruby getting faster? We will briefly talk about how Ruby program could leak and then we will go ahead and see if we can fit a little bit more in. As you are talking to pattern you see a table to over and all the pastries spill out onto the floor. That is a memory leak. I for these things and patter said if objects randomly spot everywhere that is a serious issue. That is an operating level thing. Something really want wrong. If a memory leak isn't  what is a man really? Pattern was obviously a memory leak is very simple. When you forget to delete something. As a program keeps  locking memory, or if it forgets to free Mary  if effort to free memory, they are getting deleted and your program will take up more and more memory. In a Ruby program, normally the way a leak happens, it could happen if there is a program inside of Ruby itself. Every so often there is a really Ruby core. A normal  if you accidentally make a reference to some transient objects, you don't care about the whole program, if you make a reference to one of those objects, then your object will also never get garbage collected. There is a connection between object get deleted object that will never get deleted, that object that could get delete it will never get deleted. You build up these references overtime your program you will start leaking memory. Let's look at a very simple memory. This program is theoretically fine. We have a constant with an array in it. That is a log of all the messages that have been passed into this particular method and a method called Prince message. We have a lot of only must  outputs that message out. A very simple Ruby Lee. Because we're adding each method to that array. It will never get garbage collected. We call this function 10 million times we will have added 10 million strings to Ruby's memory and those objects will never get deleted unless we clear out this delay. A very common thing to hold onto references to objects that are transient because you want to log info you store info about them in the law. If you don't make copies of that healthy objects you are trying to make laws about it will never get delete it. They will never go away. This memory leak is very simple. If you don't care about that extra memory leak being used. Let's look at a slightly more tricky memory the. Objects based define finalize her. If you have never used this method and means you are probably just an ordinary programmer. It does not get used very often. Idea you find a single person who has ever used this method and not created a memory leak. This is a memory leak. It takes two arguments. The first is any all object in Ruby memory and the second one is a  whenever that object gets garbage collected, that will get calls. This lets you call a little bit of cold. There are all sorts of clever little things you can do with this. The reason why this leaks memory is right here. Even though that doesn't look like it has a reference, it does. Whenever you create a  in Ruby all locally available variables that were because they might get used later. You can reference. That's the reminder this works. Whenever that is called you need those local variables. We haven't called inside itself is actually that local space. We are using it right there. Self is available. That has a reference to self. The object you want to garbage collect is reference by the function that will only get called when the object is garbage collected. We can't get rid of that function until the object is now have this weird circular. We will call function on the object is collected at that function references that object. There will be a reference to the never garbage like this object and the name will never get calls. This happens to every single person every time they use the finalize her. It happens to me all the time. There is a very simple way around this. We have to create that in a different context so it doesn't have access to that object we are creating the finalize her. Here we call a separate method on the class. Self will be the class, not the actual instant and that method goes ahead and takes in the name and it returns and then sells is the class because of the class method. This means that now this doesn't have a reference to the object that will be garbage collected and you have gotten rid of the memory leak. Now those objects can get delete it. This is all good but I'm getting hungry and I have to go to lunch and patter says there are lots of things we can have talked about. And you can come see me afterwards if you want to hear about any more of these things. Before I go, I wanted to talk to myself there. He has something interesting to tell you. At that moment a Rick  Iraq. We're looking cat. My name is Aaron, Erin, Patterson. I want to directions were some a lot of improvements and I've been doing a lot of cool work on something called a compacted garbage collector. When things get extraordinary they may and stored all over the place. I want to bring them in so there are tables that don't have any objects on. If you want to hear more about this I may be in the Biltmore after lunch giving a talk about this. And so Aaron headers on leaves you with that knowledge. And then looks like raccoon but a little different who are you? My name is  and it is like a Japanese restaurant. One of the really cool things about Ruby is there aren't just right working. We have in Japan because we were the ones who created the garbage collector and we do a lot of the work. What are you doing balancing always paints  balancing pastries? I keep dropping always pastries. One of the things that makes it really hard is the garbage collector. If you want to learn more about that, maybe any Biltmore anything later today you can see not a sneaky but someone  talk about the garbage water. Thank you all for coming. A special thanks who did all the illustrations. Can you give her a round of applause? [ Applause ] And again, if you have any questions feel free to Tweet me or email me or come out to me at any point in this conference. I have a lot of raccoon illustrations or we can talk more about Ruby's garbage collector. Thank you.
>> [ The event is on break for break for  lunch ]
>> [ Captioners Transitioning ] 

>>
>>  Hello, hello, hello. How are we doing? Are we a live out there? Is anyone even listening to me? There we go. We have a fun session here. We were going to have a table but we are going without a table because we can do that. 
>> Incident response. 
>> We're going to do a little bit of trivia before we turnover to Betsy. And our brave volunteers. We are going to do Live Mob Refactoring today. This will be fun.  So, this hotel was such a known magnet for celebrities that crowds of people used to wait, I think this hallway is the one upstairs. This is not clear in the sentence. Hoping to see stars leaving events. Eventually the hotel hired a man who would discreetly handed business card to anyone's name for more than 20 minutes to let them know they had overstayed their welcome. With that, I will turn it over to Betsy. 
>> [ Applause ] 
>> Hey, everyone. Welcome to Live Mob Refactoring . The title is correctly printed. We are evolving the exercise when we had to tell Abby what to print. We changed our minds. It is very agile. Today we're going to do a demo with three of the folks from the scholars program. 
>> I am alley. I am Jennifer. I am a bead. -- Habib. 
>> Raise your hands if you're looking for employment. 
>> Were going to do a demo. Mobbing is an understood and underutilized technique. A lot of times people think of mobbing as pairing up with more people but why would I want to do that. That is all that inefficiencies and also none of the good parts. It's important to remember that that is not what mobbing is. Mobbing is an effective tool for getting people on the same page. Is not efficient for producing code and we do not expect to finish the exercise but it is a useful tool for making sure everyone understands what's going on. It can be useful for establishing contacts before you split apart and work on things in parallel. I prefer relatively lightweight facilitation approach. The two things I think are important are the person typing is not contributing anything other than typing. 
>> Betsy has asked me to stay -- say almost nothing on stage. That's hard for me. 
>> It can also be helpful to have someone who is neither typing nor actively participating in making code happened but rather just serving as track cop. That's me. I also do this for money. If you would like me to do this, come see me afterwards. Gratuitous advertisement over. We will have Carrie Miller noted poker expert come on stage and explain the problem we're trying to solve now. 
>> [ Applause ] 
>> I also play poker for money. If you'd like your team to play poker with me. I play a variety of different poker games. The one you've probably seen is a game called five card draw. Every player is still five cards and then they choose, give me three, give me two, and the goal is to make your best five cards poker hand. The chance of ranked according to how difficult it is to make that particular hand. It is harder to had two pairs in your hand in one.. So two pair beat one.. The problem we're doing today will be poker dice. Dice you may note only have six sides. We had to get rid of some of the numbers. All of the numbers between 2 and 8. And players roll the dice three times and make their best five dice hands. 
>> All right. 
>> We started on this problem yesterday so that were not starting from complete scratch. This is very much mid-process. I'm sure some re-factoring will need to happen. Sam, would you mind switching to -- yes. 
>> Let's go to the test file and let's run the test. 
>> We are lazily evaluating this session. 
>> We have 32 tests, 29 are pending and zero or finished. And now are going to try to make more of the test pass. -- Tests pass. 
>> [ Silence ] 
>> Someone tell me what to do. Run. 
>> As a brief note, they may at some point as the audience questions to see if they have ideas. Please raise your hand so I can call on you if this occurs. 
>> These once running and everything below that is not. 
>> We are taking a hand and the hash of the counts by each day and we have one pair and two pair in terms of these counts. I think we pulled out a third of them as well. What should we do next? 
>> [ Indiscernible -- speaker too far from mic ] 
>> Three of a kind. 
>> I will just run that. It does not respond to three of a kind and incorrectly scored as busted. 
>> The first thing we should do is re-create the three of a kind. 
>> [ Silence ] 
>> Now it saying did not score as three of a kind. 
>> This is Stan Livingston gray -- 
>> I am literally and all. It took me a good five minutes to understand what is going on. 
>> So I guess we can just copy this. Does that look good? Can we add that to busted? 
>> Good call. 
>> Now it tested passing. 
>> [ Applause ] 
>> Are all of the other tests still passing? 
>> Yes. 
>> Cool. What next? 
>> Cool. 
>> We are seeing that it is not responding to a straight and responding as busted. 
>> Four Straits. 
>> Cool. New failures. It's a repetitive process. 
>> What makes a hand a straight? 
>> [ Indiscernible -- speaker too far from mic ] 
>> Ace, King, Queen, Jack, 10. We know for sure that that is a straight. I think we might need to assign a value or we would need to check for the most specific characters. 
>> That is true. 
>> Okay, we need to do this [ Laughter ] 
>> Here is a question. It can be useful in the circumstances. Is good to examine our assumptions and go what cases is it not covering. Are there any cases this is not covering? I'm not sure. 
>> Yes. Marty is asking does the order matter? We would need to order them. 
>> To do that, -- you could sort the hand. Yes. That sounds like a very poker and dicey thing to do. 
>> I am stupid because string doesn't respond. 
>> How do we want to turn this into something that we can resort? 
>> We could make it an array? 
>> There is some math. Something about a rule of us some of values. 
>> We only have six possibilities. So what is the sort for those? What was your question? 
>> If we are defining an order, how do you want to, how do we want to turn that order into a sort? Good the audience please raise their hand if they have comments? 
>> [ Indiscernible -- speaker too far from mic ] 
>> Good the audience wait until the scholars asked for help before they do so. 
>> We have all of the individual dice in her hand. We have the dice values. 
>> [ Indiscernible -- speaker too far from mic ] 
>> Come up here and yell into the microphone and tell us what to do. 
>> You need to give them a relationship between each one. That is is bigger than the king which is bigger than the Queen. Somewhere you need to have them in an order that says this is the bigger one of the smaller one so that you can sort by them. 
>> We need a spaceship operator right here. I would like us to not need to do that. 
>> I am going to do it Evan told me to do. -- Watch Evan -- what Evan told me to do. 
>> Is that helpful? 
>> I feel like we might be and one of those places that focusing two quarters desk closely on how a human was solve this problem. When I look at a straight the thing that I go, the thing that I see is that they're all different. 
>> We need to make sure we have those cards all in one hand. They don't need to be in ascending order. 
>> I think I get what you're saying. Let's keep me honest here. 
>> Yes. 
>> Will that work? 
>> I think so. 
>> Shall I run a test and see what happens? It works. 
>> [ Applause ] 
>> I would probably get cranky about there not being enough tests to really drive this. 
>> What do we want to do now? Full house? Cool. I'm not an expert, but I think that's what a full house is. Can we use that in the full house message? 
>> We are now scoring is one pair and three of a kind as well. So what are the main aspects? It rejects if you have more than one method that returns true. And so if we are defining full house in terms of one pair and three of a kind, we cannot necessarily define three of a kind as three of a kind and not a full house. So we are in trouble right now. And it is your problem to solve. 
>> Just to be perfectly clear, what is a full house quick 
>> Three of one card and two of another card. 
>> What happens if we look at this not as one pair and three of a kind but as what is currently the contents of the one pair method and the contents of the three of the kind method. 
>> [ Indiscernible -- speaker too far from mic ] 
>> For the one pair method could we check it is one pair. All three of the other characters are unique since there should really only be one pair? 
>> I like that. Yes. 
>> What? 
>> If we check for one pair in the hand of two matching character -- 
>> There is only one pair. 
>> We expect the other three to be unique characters. So not a second pair. 
>> You're talking about the one pair method and not the full house. 
>> Let's remind ourselves about one pair. He calls appear account, -- it calls a pair count, it calls the cards that they represent and we get the counts. We are already doing that check. 
>> Can we add a check that the remaining three characters are all different or no? Or all the same? 
>> For one pair? 
>> I see what you mean. It turns out that communicating about code can be hard sometimes. This is actually really hard to implement with we how -- with how we currently have this -- let's just make it pretty later. 
>> I am expecting something oppressive. 
>> I can't think of a good way to do this. 
>> I've got something. 
>> You're right. You can't just do unique and check count with unique is the same which is the way I would've approached it at first. So we throw out the pair and then we can all of the things that are left and there should be more than one of them. That's why I was struggling with it. 
>> I guess that works. 
>> Should be see if this works? Yes, it does. Accept now we have broken full house. And so now we are not scoring is one pair but three of a kind. 
>> I guess we can pull the same into three of a kind. You will notice that the scholars have much better hats than Cindy or Sam. 
>> So to do this, we need to try out, what do we need to throw out? We need to throw out the three. Incorrectly scored as busted. We know how to fix this one. Honestly, I like it. 
>> [ Applause ] 
>> All of our tests are passing. Let's go for one more. 
>> Really? 
>> Are we can cleanup the -- correctly scored is one-of-a-kind incorrectly scored as busted. Another passing test. Can we please please please cleanup busted? 
>> Can we? Are we allowed to? Yes. How can we do that? 
>> So busted is nothing else is true about it. How we are checking for unique. That involves less program -- programming than I was willing to drive into. 
>> Yes, that worked. 
>> [ Applause ] 
>> Now what do we want to do? We have 90 seconds. Can we make another test pass? Let's do it. It's checking of all of them are the same. 
>> Someone tell me what to do. Quickly. Quickly. No pressure. 
>> [ Indiscernible -- speaker too far from mic ] 
>> Is there a -- we are already counting how many -- yes. 
>> We did it. 
>> [ Applause ] 
>> Were doing the value selecting everywhere. We have three seconds. It is wizard time. We broke everything. 
>> [ Applause ] 
>> No 22nd we factoring. Think -- re-fracturing. Thank you. 
>> [ Silence ] 
>>-To. Welcome back and good afternoon. Thank you for joining us. I hope you had a good lunch and you're energized. This is the final talk today. If you're around, there was a fantastic intro ever going to dive deeper now into more implementation. Normally I would read the bio of the speaker that they provided when they submitted their proposal. In this case, Aaron Patterson  is a member of the team and to read his words, please give a warm welcome to Aaron Patterson. 
>> I am glad I gave her my less embarrassing bio. Does anyone else think it's inappropriate that we're having a ruby track inside the Crystal ballroom? Okay. I am very nervous. This is a hamburger hat. For those of you watching the livestream, this is a hamburger hat. Those of you reading the caption this is still a hamburger hat. This will be C code in this talk. This is upon. -- A pun. First I want to talk a little bit about Ruby standard library. Sorry, this is a good one. There is a library that you can install called standard. It is Ruby's standard library. If you are at the game show yesterday we were talking about the most popular and I want to make Ruby standard library one of the most popular jams. -- gems. You can configure it at all. [ Laughter ] you install it and it is a -- it is use like Robocop but you can't change anything. Just go by those rules. They are the correct rules. Go ahead and download Ruby's new standard library today. My name is RPC nine.  You may know me on the Internet as tender love. This is what it looked like online. I have two kits. This is Gorbachev puff puff thunder horse and the other is to to. I have stickers of my cats. If you want to come talk to me please say hello and I will give you a sticker. I have them. I work for a very small start up company called GitHub . We were recently acquired by a very large company. I had to change my desktop background to stay on brand. Anyway, GitHub is the first legit company I've ever worked for.  I love using it but I won't force it on you. Your pain feeds me. This acquisition by Microsoft has given me a chance to branch out. I would say it has opened a lot of doors for me. Did I say door? I meant when does for me. -- I meant it's opened a lot of windows for me. One important lesson I have learned, you may have received some random kits. Don't airdrop the people who were speaking. Which is happening to me right now. Yesterday I just got my Microsoft email address. I'm really excited about it. This is my email from Microsoft. Seriously. Please email me here. Send me many emails. Much like my regular email account it will go into an inbox I do not read. I will check it when I figure out how to use it. I hope that your emails will help to give me a better outlook on life. So now let's get to the real technical content. I hope that you will enjoy this talk. I'm going to make many power points. Actually, times new Roman is the only fun I'm allowed to use. Let's get to the actual content here. I'm going to talk about reducing memory usage and Ruby. I'm going to talk about two optimizations I wrote for Ruby 2.6. How two patches I wrote and how I came up with those patches and what tools I use and how you can do this same type of thing. So the first patch of going to talk about's for the loaded features cash and I will talk about that later. And then when I call direct marking for sequence. Before we can talk about reducing memory usage we have to be able to find what memory to reduce. The first thing I want to talk about is finding memory usage in your application. The patches that I wrote, Ruby is mitten -- written in so it has to be with the C programming language. We're going to talk about tech needs for finding memory usage and the C program. There is to main techniques I use and it's a bad cut -- technique called reading the code. It is in an efficient technique and doesn't work all of the time. It is a technique I sometimes have to use. The other tech make is and I will talk about that in a minute. With Ruby programs we have to think about two different places where we allocate memory. One is in the garbage collector and the other one is from Malik. We allocate will be art objects and we allocate other stuff for example strings are I don't know, other things using the systems. We have a lot of tools for profiling objects that are allocated in the GC.  You can use these and I encourage you to go look them up. I'm not going to talk about them today. They are not so better profiling Malik allocations. Were going to look at how to find Malik-based allocations. The technique that I use is Malik stack logging. This is a tool available on OS X. There are other tools available on Lenox and other operating systems but I do not know all of them. I will step away from this topic now. So the way you use it looks like this. You basically set an environment variable that says you want to log all Malik calls and hear what I'm doing is starting up a rails application and I print out -- enable the logger and then just pause the problem. We have to posit because OS X use random authorization. Every time you run your program stuff gets allocated to different addresses. To know what those addresses map to we have to posit program and profile it. So that pauses the program. We run this to one terminal and in another one we take the PID and run Malik  history with the PID . What this will do is have a log every time a Malik or a FEE was called . You need to have a lot of room available on your hard drive when you do this. This is just profiling a basic rails application for review -- in the log file is about 6.2 gigs. If you're going to do this on your actual app you need to have some free space. The file content looks a bit like this. Basically one line per aleck and one line for FEE and you can see where in memory the allocation happen,  what size it is and we can see what address was freed. Given that information we can reconcile a live memory in the system. It is a very simple program. We know how much memory the program was using and we can know what is allocating the most memory and we can know exactly how much memory we have allocated at the time. So that is cool but when you're looking at this the very top thing is either Malik or FEE . We don't care about them necessarily. We care about who is calling Malik. Those are the places we want to target. If we adjust that previous program just a little bit and we take a look at the caller so that we know where to look at our profile and to give you an idea of what this will look like here is a pie chart of the top allocators when booting up a rails application. So don't read this too closely. Just know you can do this. So after doing a process like this I will combine these two techniques plus reading the code and look at the functions that we are allocating a lot of memory and then figure out how we can reduce the memory usage for that particular function. So with that let's take a look at the loaded features cash. -- cache. It takes advantage of shared string optimization. Then we will look at the patch. Essentially Ruby strings allow to share the same C buffer. Let's pretend that's true for now. In this example we have three Ruby objects and they are all being represented by the same underlying string buffer. We have asked pointing at the head and Be as a substrate in the points at the next character all the way to the end. We can only do this technique and share strings like this if we are looking at some point in the middle of the strings all the way to the end of the string. Let's take a look at an example of where we cannot share a string. For example, this one. We take a sub string from the beginning to somewhere in the middle and we cannot share those. It is because Ruby the underlying C buffers need to be terminated. We have to share all the way to the end. These are not shared strings. Our shared string rule is always copy to the end of the string if you can't. That way we can represent more than one Ruby string. So what does this have to do with loaded features? Loaded features is a global variable like this and keeps track of every single file that has been required. If you do require and you look at loaded features you will see it's added a new string to that array. And this array is used as a database. We know that every time we require the same file, it is only execute once. Ruby uses this to determine whether or not a file has been required. Unfortunately, there is a little bit of a complication. When I say the same file, what does that mean? These all require the same file. The parameters we pass to require are different. This is an extreme example of this particular issue. We expect that particular file to only be executed once. That means that Ruby has to lookup if I have required this before and search through that in order to find it. The problem is, it slow. We do not want to search the array. Think of all the files in a rails application and it would take forever. In order to speed this up, Ruby creates a cache of every possible parameter that could be passed. When you acquire that file it will create a cache that looks like this. Every single key that could be passed that may map to the same file. That way when it is called again we can quickly look up and see if we have seen this key before. If so, let's go check it out. So it looks like this. Keys mapping to the array index of the file we actually require. So when we require a file we can look at the array and see what is required and say yes we have this already let's skip it. The way we generate this cashe  looks like this. It is written in C and I've translated it to Ruby. Ruby is easier to read. Do not read this closely, please. We will walk through this. Let's say we do this ABC.RP and we have a string that looks like this. The way the algorithm works as we put two pointers at the end of the string buffer and move one pointer back to the first period and then it moves the first pointer back to the 1st/and we take from the first pointer to the second pointer and the first pointer to the end of the buffer and that is our first two cashe keys.  And then it moves the pointer back again taking from one pointer to the next and then to the end. We keep repeating this until we get to the very beginning of the string and we have our entire casting, sorry about that. Let's see that again. No. No. Yes. Let's see if I can do this. Did anyone go to LA fitness while you're here? I think they just call it fitness here. I wanted to pick up some LA gear. [ Laughter ] 
>> I am distracting myself. The problem with this is that it takes some strings of the original string. It uses this RP substrate which is the same function call we basically use when we are doing square racks. When we do this it takes copies of that string. These are the objects at the bottom, four of those point to the original long buffer but these other four have to copy the string because they're not going all the way to the end. Our first optimization as we can reduce the number of Malik's and we have four Alex along the bottom. Eight Ruby objects and four new Malik allocations. The way we do that at first step as we take a copy of the string once. We create a new copy of the string that goes all the way to the period. When we take some strings of these two we are able to share these buffers and so we have four objects pointing at the top buffer and for pointing at the bottom buffer. We can also eliminate Ruby objects. This cashe is only used in C and never exposed to the Ruby user.  Today it looks like this. We have string buffers but you don't need to see these and we have a has point directly into the strings himself. So, we can eliminate all of those allocations and were just downed to two. This is the patch. A very simple patch. It is this. Very simple. Kidding. It is not simple. We can measure the impact and we will measure the impact by using allocation tracer. We require a log file and measure the number of objects allocated. Before we expect to see a bunch of string allocations and then we expect deceive fewer string allocations. I have made a graph and is not easy to read. This is what the object allocations look like. You can see that we have the blue one is Ruby 2.5 and the green one is Ruby 2.6. Were able to reduce the number of string allocations by 50%. -- We are able to reduce the number of string allocations by 50%. Let's see what it actually does and how it impacts your allocation. The X axis is the sample number. The Y access is the amount of memory that we allocated. If it's closer to the origin that's better. Before this patch we are up there this absolutely depends on your application. If you acquire more files you will save more memory. The more you load the more you save. How much would you pay for this feature? You can have it today when you up great to Ruby 2.6. I cannot tell you how much this will actually save for your particular application. It depends on how many files you acquire. At work we require a lot of files. After I got done writing this patch, I was very proud of myself. I debugged the code, I wrote the patch, I made sure that at work, I had a nice graph and I was really pleased with myself. I was so happy. I posted the patch here and then I got a comment. It was from this person named funny falcon. Did you compare it to this other one. I don't know about this other one. I will click on that link. So I clicked on the link and it turns out he had found exactly the same problem I was talking about and submitted a patch as well. He submitted his five years ago. It was not applied. So I applied his patch. 
>> [ Applause ] 
>> Thank you. The lesson from this story is always -- all right. Funny falcon is now a Ruby commit or. He can do it himself next time. Let's move onto the next patch. This one is called instruction sequence marketing. This tech make requires that we know a little bit about how Ruby's virtual machine works. We are going to implement a tiny virtual machine before we write this patch. Ruby's virtual machine is a stack based VM. We have a list of instructions and a list of instructions like this. We have a STACK. We can think of instructions as our program and the stack as our workspace. These instructions, you can think of each instruction as an array where we have the instruction, the particular instruction and the operands for the instructions. The way that the VM works is the VM keeps a program counter. It points at the next instruction that's going to be executed. It executes it and increases the increments of the PC. In this case we will push three onto the stack and five on to the stack and finally the ad instruction will pop two off and add them together and push the result value back onto the stack so we get eight. So how do we get these instructions? We see simply how the VM works but where did the instructions come from? Your Ruby programs are compiled, before it's ever run is compiled into byte code and it has to go through a few processing faces. The faces are very start out with source code which is the code that you wrote for the new standards you downloaded and then it gets transformed into an ASP and that's transformed into a list and the link list is transformed into byte code. We can break these phases up in the two main sections where we have parsing and compiling in where those two overlap, it's a little bit gray but that is how I think about it. The link list phases where we have optimization apply to the code. If any code is dead it gets remove their. It happens in that face. They're easy to manipulate. And then it's turned into a byte code. That is what we execute. So the data structure involved, we have an ASP abstract syntax tree, I'm not sure why it's called abstract because we use it is very concrete. That is what people call it. It is just a tree data structure. So we take our source code for example this 3+5 and convert it to a AST.  Appointed a three and a five and if we look at how these are implemented under the hood they are implemented as Ruby objects. These are Keynote objects. You just never see them. These objects are converted into a list and the way that we convert them into a link list is by walking each note in the tree. So we start out with plus. Plus says I have children and I need to do process my children first. So I will visit your children first. The three has no children and we end up with the push instruction with the number three. That we visit the five child and have another push instruction. Finally there's no more children so we out of plus instruction on the end. If we were to convert it into Ruby, it would look like this. We process all of the children before we process the parent object. Next we apply optimization. I'm going to hand this a. -- This a. I am going to hand wave over this part. We're talking about memory optimization and not runtime optimization. So we start out with the link list and we hand wave and this is are optimized link list. They are the same. There we convert it. What is byte code? It is binary code executed by the virtual machine. If you look at the implementation it is a list of numbers. Truly just a list of integers. So where does it come from? We take the byte code and we have to translate all of these link list nose into integers. We translate push three into some number that represents first like 123. And then we have the number three and we will use that to represent three. We have a push five so we will use 1234 are push and then we add and we represent that as 456. And then we have our byte code. This link list gets translated into Ruby objects and translated into byte code which is again a Ruby object. All of these are Ruby objects. It is important for optimization. We will get back to that in less than 12 minutes. Let's make a simple VM. We know how it works. We need to be able to push something onto the stack. Instead of these arrays we have just the list. We cannot push RPC one at a time. We have to push two, two and then one. We will write our program to take that into account. We have our simple VM. All it does is exactly what we have described in this code. We increment the program code by an extra one whenever we encounter a push instruction. This is our entire VM. We have learned how compilation works. We have learned how the VM works. I think this is a good point for us. We are doing well. I want to look at one more program before we can get into this memory optimization. That is the hello world program. It is almost exactly the same as our integer based mathematics program but instead were using string.  So we end up with the AST  just like we did in the mathematics example. When Ruby builds this AST it actually allocates  Ruby string objects. They are both Ruby string objects. They are stored in the AST. When we take the AST and converted to a linked list  we get these push operations and they also have those Ruby objects. They are the same Ruby object that we allocated when we parse the code. But we translate the byte code, we go through here and we have to actually use an address for the string. Remember we can only deal with integers. We have an integer that is a pointer to the object. We have the object address. So we have two Ruby objects and the object addresses to correspond. So now when we write our VM we don't have pointers. The only -- they only exist in see. So we will use our VM. The thing I need you to note here, you do not need to read it. Were executing the byte code twice. We execute -- we are executing the byte code twice. We executed twice. Hello world. Hello world world. The reason is we allocated Ruby objects here and we push these Ruby objects onto the stack and we will run through this again. We push hello we push world and when we called the append instruction this is a destructive operation. That will mutate the object but those objects are the same ones that were in our instruction sequence. When they objects on the stack it mutated objects in also get mutated. If we execute the program a third time it will printout hello world world world. So we will see two many worlds -- so we will see too many worlds. We have to change our VM a little bit. We actually need to copy the object before we push it onto the stack. All this does is copy the object before we push it. When we run the program again, instead of pushing the object we push a copy and the copy gets mutated and everything works the way we expect. If we think about this in terms of object allocation, we are allocating two strings and we allocate two strings of runtime. We have to do those before we push them onto the stack. As a side note, that's why it helps us. In this case it is telling Ruby, we cannot mutate the strings. If we cannot mutate them, it means you can push the original onto the stack and not duplicate every time. So we will allocate two strings and only allocate two strings of compile time and only compile one at runtime. So now that we understand how the VM works, we understand why this optimization helps us. I think that is really cool. Reducing memory usage. We have gone through all of this background and we are going to, I think we understand enough detail where we can look at this allocation technique. As we said earlier, right code is stored on sequences. Instruction sequences are just Ruby objects. If you see that around it means instruction sequence. If we look at these objects we will see that this poinsettia list of integers. The layout as we saw during compile time we have to point, we only have integers so we have to point at the address of those Ruby objects. We may have some strings in here that point to hello and world. The string objects are managed by the garbage collector. So it's also managed by the garbage collector. Imagine if these two strings were Malik  and your program ran, what's going to happen? Your program is going to blow up. This got a B for the -- a for the garbage collector to know about those particular strings. Imagine I said that perfectly on time. So how do we deal with this? How do we prevent those string objects from going away? The techniques that we used up until Ruby 2.6 was the mark array. The instruction sequence object would also contain a reference to an array. When your program was being compiled as the instruction sequences were being built, anytime of Ruby object was created like for example those strings, the string would be added to the mark array . It's pointed to by the byte code as well as the marker -- as well as the mark array. So the reason this works is because when the GC marks the instruction sequence object, it says hey, I also have an array. And then the array says I have some stuff too. We will Mike that. It marks those strings and keeps them alive and that way your Ruby program will not blow up when you executed. And so this mark array has a couple of problems. The first one is an organizational problem. We have what I think of as duplicate information. Two references to each object. The only reason we have those references from the array is to keep those objects alive. If we look at byte code being executed, it is difficult to tell that this right code contains references to Ruby objects. It is confusing to me. I think these two lines are hitting references. References but is not obvious. The other issue is when you add an object to an array you know that Ruby already expands the array for you to have more capacity. When you add one object it doesn't just increase the capacity of the array by 1. If you did that it would be yes. It allocates a bunch of stuff if we were to map that out, the actual number of elements it would look like this. The difference between this greenline and blew my -- and blue line and were not using it until we fill it up with more rap checks. It's functional and we use it. This array and these instruction sequences, disarray lives forever. At least for the life of your program. We have this empty space sitting there unused and that really bothers me. I like to use stuff. How can we fix this? When we we can fix this is to remove array bloat. We can resize the Arodys -- we can resize the arrays. We can remove the array and do that with the program almost exactly like the VM that we wrote. If it could decode these instructions and mark that object then we could accomplish this without the array. We can do this almost the exactly same way as our VM. We have something written almost like the VM but rather than executing the instructions we mark the parameters. That is entirely what this technique is. If we use is we can eliminate the array completely and mark these objects directly. We are marking the objects directly. It is a direct marking technique. In the real world, we are able to reduce the array allocation and you can see and we allocate 35,000 which is a .5 thousand. Over all a 34% reduction. This is a map on Ruby 2.5. This is after Ruby 2.6. Overall process memory reduction, this is before it depends on how much code you load. The more you load -- thank you. [ Laughter ]. I did. How much did you pay for this? You can have a today by upgrading to Ruby 2.6. This is where the patches. The actual code is right here. We learned about VM. We learned about memory management. Most of all we learned about ourselves. Everyone please upgrade to Ruby 2.6 Thank you very much. 
>> [ Applause ] 
>> [ Music ] 
>> Hello. It's time to talk about program he in Ruby3 with guilt . My English is not so good so you can download this presentation. Today I want to talk about and introduce Ruby 2.6 and some contrition -- contributions of mind. I want to share with you about the guild program. I am a programmer. My mission is to improve the performance please stop by our booth. 
>> [ Applause ] 
>> There's only one photo in this presentation. In Ruby 2.6 there are several performance improvements. May be the biggest one, [ Indiscernible ] is 1.5 times faster. It is 2.6 times faster. The biggest contribution 
>> It's a big feature. I don't show the details but it uses Malik to allocate and free memory. The combination for the speed and the space, I don't show details because I only have 40 minutes. Generally speaking the memory moving technique, we use conservative garbage collection. We can speed up the allocation for memory and in this case a small number of objects and string base, it is difficult so it is a future task. You can see, the x-axis and the Y axis shows how to speed up. You can see the improvement. This is because we use another optimized tech make. We can see the improvement [ Indiscernible ] it is 50% faster. And also we can see the allocation. It is 100% performance improvement. It is not used for such a big object. With transient heap you can improve the applications. It should improve the performance. Your application can. So there is a good performance result. It depends on the application. So please try it. You can try it now. So back to the main topic. This application is not fixed yet. It is not finished. So your contribution is highly welcome. If you have any interest about guilt or something like that, [ Indiscernible ]. Let's talk about the guilt background. Yesterday -- [ Indiscernible ]. The biggest problem is suing the object -- is showing the object and it's difficult to correct. I want to achieve this further productivity. Your computer has many [ Indiscernible ]. On the current MRI it cannot provide a for a many core. I want to show you a convenient way. To achieve these goals I proposed guilt. -- I propose guild. This idea is very simple. The program is sharing objects between threads. The idea is simple. You can do this between guild. It's very good for productivity. I want to share the current discussion topics. However, threads belonging to different guilds, [ Indiscernible ] in Ruby. This is an example. I think this is very similar to threads programming on Ruby. In this case, expression why an expression [ Indiscernible ]. Normal strings -- there are several objects that we can share between guilds. This kind of object [ Indiscernible ]. We can do this without safety concerns and one guild. In other words, you cannot make a thread unsafe program on guilt. You cannot write. Most of the objects for [ Indiscernible ], only a few objects are shared. We only need [ Indiscernible ] sharing object to make the program. Ruby programs make many strings. They are mutable and non-shareable. A non-shareable object is a member of one guild. The other guild non-shareable objects -- you can use only one guild. It is very compatible with Ruby. So you can make a compatible program with Ruby two and Ruby three. You can make compatible shareable objects. Other than these four types of objects, you can define special types. Shareable objects -- we can share the non-shareable in guild. We need to keep this assumption. The first shareable object is an immutable object. Sharing immutable objects is not an issue. I think it is easily done. It is not equal to the [ Indiscernible ] objects. For example, this is immutable. And also, numerical objects or symbol objects and literal objects are immutable. You can share them. Single objects are immutable if they don't have [ Indiscernible ]. It is very difficult and we need to introduce more considerations and protocol to share those immutable objects. It is easy to make some type of program. However, we need to introduce new protocols and shareable objects because [ Indiscernible ] mutable objects -- we need to introduce some special protocols that prohibit sharing mutable objects. There is no time to discuss this further. Sometimes we need to share data structure. To share the data structure, we need to introduce some of the special protocolsto introduce some of the special protocols  for the content over mutable objects. I have not implemented it yet. For example, the [ Indiscernible ] shares mutable data in the structure using [ Indiscernible ] memory with FTM. It's not so hard to implement. Additional overhead because we need to introduce the transaction. This kind of overhead, as I said, only a few shareable objects that we need to use on the [ Indiscernible ] program. The last one is isolated [ Indiscernible ]. For example, [ Indiscernible ]. Sometimes we want to pass these over to another guild. To achieve this, we introduce [ Indiscernible ]. If we make an isolated probe this access is prohibited. This would produce a runtime error. We can introduce some kind of channel object with [ Indiscernible ]. So in this example, [ Indiscernible ] transformed to the isolated probe and in this case this line is long. [ Indiscernible ] in this case -- [ Indiscernible ] is using similar ideas. [ Indiscernible ] the name is different but the ideas are similar. I think this approach -- okay. We need to prepare and communicate. I designed this at this moment. This means sending only the lightweight object. They are not shareable and we have [ Indiscernible ]. This is by using API. It is a guild component. I will try to show how to send an object to the guild. In this case the object is going to go guild one. [ Indiscernible ] this is a very simple example of moving it over with guild. We can't share those objects. We need to do something. A cookie is easy to understand. If you want cookies or [ Indiscernible ] the object can be sent to guild too. If we move the object to the other guilt, we can access guild one. In this case, if we move one just after [ Indiscernible ] from guild one we can access [ Indiscernible ] object. It is faster. We do not need to copy everything. For example, it makes an I/O object and moves it to [ Indiscernible ] guild. After that, it doesn't need to anymore. This is the summary of the shareable's and the non-shareable's. These are the details. We cannot share the mutable objects. In this program we can share some kind of shared object extensively. But with guild we can make the correct known data [ Indiscernible ]. This is one discussion. I designed communication API based on [ Indiscernible ] but we have another option. [ Indiscernible ] for example, we can transfer the terminal object. We have two options. There are advantages and disadvantages and we need to compare the pros and the cons and we need to decide which we should use. I wanted to introduce the idea using [ Indiscernible ]. We need to consider them more. Another discussion is [ Indiscernible ] for example, we want to use the channel or [ Indiscernible ] we need to communicate with [ Indiscernible ]. We need to communicate with one channel. One communication channel. I think if we can provide good API, for example, we can retrieve the [ Indiscernible ] and also the processes we can channel with [ Indiscernible ]. I think we can introduce some techniques. Another subject is naming. In Ruby, the naming is important. The name is a codename. Some people say that guilt is not a good name. I want to share the codename. We are seeking a few good names. I prepared the CPU machine. It's a high processing CPU. We have two CPUs. [ Indiscernible ] 
>> [ Captioners Transitioning ]
>> So increasing this number we can compare with the execution. So the increment is maybe 15 or 16 and 40 CPUs. The next one is the number of guilds to 40 and change the number. In this case we can see -- we cannot see the performance improvement -- it shows the execution and so here and execution after three hours and using guild  -- This is the ratio. So if we use -- only a few numbers and the overhead of guilds is very high and there are no improvements here. If we increase -- we can see the whole thing improve. And the last demonstration is a wildcard example. And so the indication is in this is 1.7 seconds and the 40 guilds is :06. This is because the object allocation -- and this is the implementation limitation I think. So we need to improve. So they talk about -- my contribution and I use the idea of guild  and the implementation and the demonstration. So there's no time for -- if you have any questions or comments, I'm happy to answer. Thank you so much. [ Pause ] 
>> [ The event is on a break.  The session will reconvene at 3:50 p.m. PST .  Captioner on standby.]a break.  The session will reconvene at 3:50 p.m. PST .  Captioner on standby.] 